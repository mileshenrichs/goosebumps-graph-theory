<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>Goosebumps</title>
</head>

<body>
<style>
    @import url('https://fonts.googleapis.com/css?family=Roboto:400,700');

    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    text {
        font-size: 4px;
        font-family: "Roboto", sans-serif;
        fill: rgba(255, 255, 255, 0.7);
        pointer-events: none;
    }

    circle {
        stroke: black;
        stroke-width: .6;
    }
</style>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-dsv.v1.min.js"></script>
<script src="https://d3js.org/d3-fetch.v1.min.js"></script>
<script>

    const svg = d3.select('body')
        .append('svg')
        .attr('width', '100%')
        .style('height', '100vh')
        .call(d3.zoom()
            .wheelDelta(wheelDelta)
            .on('zoom', handleZoom))
        .append('g');

    d3.json('data.json').then(data => {
        const { nodes, links } = data;

        const simulation = d3.forceSimulation()
            .nodes(nodes);

        simulation
            .force('charge_force', d3.forceManyBody().strength(-25))
            .force('center_force', d3.forceCenter(500, 500))
            .force('links_force', d3.forceLink(links).id(d => d.pageNo).strength(1));
            // .force('collision_force', d3.forceCollide(14));

        const link = svg.append('g')
            .classed('links', true)
            .selectAll('line')
            .data(links)
            .enter()
            .append('line')
            .attr('stroke-width', 2);

        const node = svg.append('g')
            .classed('nodes', true)
            .selectAll('g')
            .data(nodes)
            .enter()
            .append('g');

        const circles = node
            .append('circle')
            .attr('r', 6)
            .attr('fill', page => {
                if(!page.utility)
                    return 'blue';

                if(page.utility > 0)
                    return 'green';

                if(page.utility < 0)
                    return 'red';
            });

        const nodeLabels = node.append('text')
            .attr('dx', 0)
            .attr('dy', '.35em')
            .attr('text-anchor', 'middle')
            .text(page => page.pageNo);

        const edgePaths = svg.selectAll('.edge-path')
            .data(links)
            .enter()
            .append('path')
            .classed('edge-path', true)
            .attr('fill-opacity', 0)
            .attr('stroke-opacity', 0)
            .attr('id', d => 'edgepath_' + d.source.pageNo + '-' + d.target.pageNo)
            .style('pointer-events', 'none');

        const edgeLabels = svg.selectAll('.edge-label')
            .data(links)
            .enter()
            .append('text')
            .style('pointer-events', 'none')
            .classed('edge-label', true)
            .attr('dx', 80)
            .attr('dy', 0)
            .attr('font-size', 10)
            .attr('fill', '#aaa');

        edgeLabels.append('textPath')
            // todo: this xlink:href property is significant!  this value is probably supposed to correspond to the id of a path
            .attr('xlink:href', (d, i) => '#edgepath_' + d.source.pageNo + '-' + d.target.pageNo)
            .style('pointer-events', 'none')
            .style('text-anchor', 'middle')
            .attr('startOffset', '50%')
            .text((d, i) => 'label ' + i);


        simulation.on('tick', () => {
            circles.attr('cx', d => d.x)
                .attr('cy', d => d.y);

            nodeLabels
                .attr('x', d => d.x)
                .attr('y', d => d.y);

            link.attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            edgePaths.attr('d', d => {
                return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
            });

            edgeLabels
                .attr('transform', function(d, i) {
                    if(d.target.x < d.source.x){
                        const bbox = this.getBBox();
                        const rx = bbox.x + bbox.width / 2;
                        const ry = bbox.y + bbox.height / 2;
                        return 'rotate(180 ' + rx + ' ' + ry + ')';
                    }
                    else {
                        return 'rotate(0)';
                    }
                });
        });

        const dragHandler = d3.drag()
            .on('start', dragStart)
            .on('drag', dragDrag)
            .on('end', dragEnd);

        function dragStart(d) {
            console.log(d);
            if (!d3.event.active) {
                simulation.alphaTarget(0.3).restart();
            }
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragDrag(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragEnd() {
            if(!d3.event.active) {
                simulation.alphaTarget(0);
            }
        }

        dragHandler(circles);
        dragHandler(nodeLabels);
        dragHandler(link);
    });

    function handleZoom() {
        svg.attr('transform', () => d3.event.transform);
    }

    function wheelDelta() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1) / 2000;
    }
</script>
</body>